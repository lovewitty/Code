WinDBG 提供了多种设断点的命令：bp, bu, bm, ba
bp 命令是在某个地址下断点， 可以 bp 0x7783FEB 也可以 bp MyApp!SomeFunction 。 对于后者，WinDBG 会自动找到MyApp!SomeFunction 对应的地址并设置断点。 但是使用bp的问题在于：1）当代码修改之后，函数地址改变，该断点仍然保持在相同位置，不一定继续有效； 2）WinDBG 不会把bp断点保存工作空间中 。  所以，我比较喜欢用bu 命令。
bu 命令是针对某个符号下断点。 比如 bu MyApp!SomeFunction 。 在代码被修改之后， 该断点可以随着函数地址改变而自动更新到最新位置。  而且bu 断点会保存在WinDbg工作空间中， 下次启动 Windbg 的时候该断点会自动设置上去。
另外，在模块没有被加载的时候，bp 断点会失败（因为函数地址不存在），而bu 断点则可以成功。 新版的WinDBG中 bp失败后会自动被转成bu 。
bm 命令也是针对符号下断点。 但是它支持匹配表达式。 很多时候你下好几个断点。 比如，把MyClass 所有的成员函数都下断点： bu MyApp!MyClass::* ， 或者把所有以CreateWindow开头的函数都下断点： bu user32!CreateWindow* 。
以上三个命令是对代码下断点， 我们还可以对数据下断点。
ba 命令就是针对数据下断点的命令， 该断点在指定内存被访问时触发。 命令格式为
ba Access Size [地址]
Access 是访问的方式， 比如 e (执行)， r (读/写)， w (写)
Size 是监控访问的位置的大小，以字节为单位。 值为 1、2或4，还可以是 8（64位机）。
比如要对内存0x0483DFE进行写操作的时候下断点，可以用命令 ba w4 0x0483DFE
这里顺便提以下其他断点命令：
bl  列出所有断点
bc  清除断点
bd 禁用断点
be 启动被bd 命令经用的断点